from Crypto.Cipher import AES
from bitstring import BitArray

import struct
import functools

# Randomly generated by random.org
aes_key = "ea8df4d0b45a757ca65f7e2d80fc9c37".decode("hex")
aes_iv ="e25cac42e472c1a6bc8143959d9cb014".decode("hex")

#
# Begin of decorators
#
def structurize(func=None, bytes=None, blocks=None, shift=None, fmt_in="I", fmt_out="I"):
	# Next time we'll be decorating method
	if func is None:
		return functools.partial(structurize, bytes=bytes, blocks=blocks, shift=shift, fmt_in=fmt_in, fmt_out=fmt_out)

	# Register function property
	func.input_blocks = blocks
	func.input_bytes = bytes
	func.input_shift = shift

	# Wrap actual method
	@functools.wraps(func)
	def _inner(inp):
		return struct.pack(fmt_out, *func(*struct.unpack(fmt_in, "".join(inp))))

	# Done
	return _inner

def consume(func=None, bytes=None, blocks=None, shift=None):
	# Next time we'll be decorating method
	if func is None:
		return functools.partial(consume, blocks=blocks, bytes=bytes, shift=shift)

	# Register function property
	func.input_blocks = blocks
	func.input_bytes = bytes
	func.input_shift = shift

	# Done
	return func

# Formats the raw input values by concatenating the number strings
def raw(inp):
	return inp

@structurize(bytes=24, shift=12, fmt_in="IIIIII", fmt_out="BBB")
def naive_estimate(x1, y1, z1, x2, y2, z2):
	a = (x2 - x1) & 0xFF
	b = (y2 - y1) & 0xFF
	c = (z2 - z1) & 0xFF

	return a, b, c

@consume(blocks=6, shift=3)
def better_estimate(inp):
	if len(inp) == 24:
		x1, y1, z1, x2, y2, z2 = struct.unpack("IIIIII", "".join(inp))

		a = ((x2 - x1) >> 8) & 0xFF
		b = ((y2 - y1) >> 8) & 0xFF
		c = ((z2 - z1) >> 8) & 0xFF
	else:
		x1, y1, z1, x2, y2, z2 = struct.unpack("HHHHHH", "".join(inp))

		a = (x2 - x1) & 0xFF
		b = (y2 - y1) & 0xFF
		c = (z2 - z1) & 0xFF

	return struct.pack("BBB", a, b, c)

@consume(bytes=3, shift=1)
def running_merged(inp):
	return chr(ord(inp[0]) ^ ord(inp[1]) ^ ord(inp[2]))

# XORs the raw input value dimensions together
def merged(inp):
	res = list()

	for i in xrange(len(inp) - 2):
		res.append(chr(ord(inp[i]) ^ ord(inp[i + 1]) ^ ord(inp[i + 2])))

	return res

# Applies an iterated Von Neumann extractor to the input values' dimensions
def von_neumann(inp):
	bitstr = reduce(lambda s, i: s +  "".join([bin(ord(j))[2:] for j in i]), inp)

	output = ""
	while len(bitstr) > 1:
		current_scope = bitstr[0:2]

		if current_scope == "01":
			output += "0"
			bitstr += "1"
		elif current_scope == "10":
			output += "1"
			bitstr += "0"
		elif current_scope == "00":
			bitstr += "0"
		elif current_scope == "11":
			bitstr += "1"

		bitstr = bitstr[2:]

	bytes = [output[x:x+8] for x in range(0, len(output), 8)]
	del bytes[-1]
	return map(lambda b: BitArray(bin=b).bytes, bytes)

# Optimized version of the above Von Neumann
def von_neumann2(inp):
	remaining = ""
	remaining_length = [0]

	def bits_iterator():
		for byte in inp:
			bits = "{0:8b}".format(ord(byte))

			yield bits[0:2]
			yield bits[2:4]
			yield bits[4:6]
			yield bits[6:8]

		i = 0
		while remaining_length[0] > 1:
			yield remaining[i:i+2]
			i += 2
			remaining_length[0] -= 2

	output = []
	bit_output = ""
	bit_count = 0

	for current_scope in bits_iterator():
		if current_scope == "01":
			bit_output += "0"
			bit_count += 1

			remaining += "1"
		elif current_scope == "10":
			bit_output += "1"
			bit_count += 1

			remaining += "0"
		elif current_scope == "00":
			remaining += "0"
		elif current_scope == "11":
			remaining += "1"

		remaining_length[0] += 1

		if bit_count == 8:
			output += [chr(int(bit_output, 2))]
			bit_output = ""
			bit_count = 0

	return output

# Applies AES-CBC to each of the inputs in sequence
def aes128_cbc_mac(input):
	aes = AES.new(aes_key, AES.MODE_CBC, aes_iv)
	items = ["".join(input[x:x+16]) for x in range(0, len(input), 16)]
	del items[-1] # Remove last, not aligned block
	enc_items = map(lambda bl: aes.encrypt(bl), items)
	return [byte for byte in "".join(enc_items)]
