from Crypto.Cipher import AES
import struct

# Randomly generated by random.org
aes_key = "ea8df4d0b45a757ca65f7e2d80fc9c37".decode("hex")

# Formats the raw input values by concatenating the number strings
def raw(input):
	return input
	
# XORs the raw input value dimensions together
def merged(input):
	print input[0], type(input[0]), len(input[0])
	ints = map(lambda i: struct.pack("L", i), input)
	grouped = zip(*[iter(ints)]*3)
	merged = map(lambda tuple: tuple[0] ^ tuple[1] ^ tuple[2])
	return map(struct.unpack("L"), merged)

# Applies an iterated Von Neumann extractor to the input values' dimensions
def von_neumann(input):
	print map(lambda i: struct.unpack("Q", i).bin(), input)
	def von_neumann_single(x):
		bitstr = bin(x[0]) + bin(x[1]) + bin(x[2])
		cp = copy.deepcopy(bitstr)
		output = ""
		while len(bitstr) > 1:
			current_scope = bitstr[0:2]

			if current_scope == "01":
				output += "0"
				bitstr += "1"
			elif current_scope == "10":
				output += "1"
				bitstr += "0"
			elif current_scope == "00":
				bitstr += "0"
			elif current_scope == "11":
				bitstr += "1"

			bitstr = bitstr[2:]

		return int(output, 2)

	return map(von_neumann_single, input)

# Applies AES-CBC to each of the inputs in sequence
def aes128_cbc_mac(input):
	aes = AES.new(aes_key, AES.MODE_CBC)
	items = []
	print input
	for item in input:
		input_str = bin(input)
		items += struct.pack("I", aes.encrypt(input_str))

	return items