from Crypto.Cipher import AES
from Crypto.Hash import SHA256
from OpenSSL import rand

import struct

# Randomly generated by random.org
aes_key = "f28ea52a9a0e07e60683c0330a216d90".decode("hex")

# Generates a random number by making a number of the SHA-256
# hash for each of the extracted inputs
class SHA256Gen:
	name = "sha256"

	def __init__(self, input):
		self.input = list(input)
		self.input_length = len(input)
		self.sha256 = SHA256.new()
		self.index = 0

	def get_rand(self):
		item = self.input[self.index]
		self.sha256.update(item)
		processed = struct.pack('B', reduce(lambda bytes, byte: bytes ^ byte, map(lambda byte: ord(byte), self.sha256.hexdigest().decode("hex"))))
		self.input[self.index] = processed
		self.index = (self.index + 1) % self.input_length
		return processed

# Generates a random number by making a number of the SHA-256
# hash for each of the extracted inputs
class SHA256GenV2:
	name = "sha256v2"

	def __init__(self, input):
		self.input = input
		self.next = []
		self.input_length = len(input)
		self.sha256 = SHA256.new()
		self.index = 0

		self.get_rand = self._a

	def _a(self):
		self.sha256.update(self.input[self.index])

		processed = 0
		for byte in bytearray(self.sha256.digest()):
			processed ^= byte
		processed = chr(processed)

		self.next += [processed]
		self.index += 1

		if self.index == self.input_length:
			self.get_rand = self._b
			self.index = 0

		return processed

	def _b(self):
		self.sha256.update(self.next[self.index])

		processed = 0
		for byte in bytearray(self.sha256.digest()):
			processed ^= byte
		processed = chr(processed)

		self.next[self.index] = processed
		self.index = (self.index + 1) % self.input_length

		return processed

# Generates a random number by applying the AES counter cipher to the
# sequence of extracted inputs
class AES128CtrGen:
	name = "aes128_ctr"

	def __init__(self, input):
		self.input = input
		self.input_length = len(input)
		self.counter = 0
		self.aes = AES.new(aes_key, AES.MODE_CTR, counter = lambda: struct.pack("Q", self.counter) + ("\x00" * 8))

	def get_rand(self):
		item = self.input[self.counter % self.input_length]
		processed = self.aes.encrypt(item)
		self.counter = self.counter + 1 % self.input_length
		return processed

# Generates random numbers by using the OpenSSL pseudorandom number
# generator with the entropy coming from the extracted randomness
class OpenSSLPRNGen:
	name = "openssl_prng"

	def __init__(self, input):
		self.prng = rand
		self.prng.cleanup()
		self.prng.seed("".join(input))

	def get_rand(self):
		return self.prng.bytes(1)

class DummyGen:
	name = "dummy"

	def __init__(self, input):
		self.input = input
		self.index = 0
		self.length = len(input)

	def get_rand(self):
		if self.index == self.length:
			raise StopIteration

		byte = self.input[self.index]
		self.index += 1

		return byte
